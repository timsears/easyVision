{

allowUnfree = true;

allowBroken = true;

packageOverrides = super: let self = super.pkgs; in
rec {
haskellngPackages = super.haskellngPackages.override { overrides = localPackages;};
haskell-ng.packages.ghc763 = super.haskell-ng.packages.ghc763.override { overrides = localPackages;};
haskell-ng.packages.ghc784 =  super.haskell-ng.packages.ghc784.override {overrides = localPackages; };

# extend haskell package universe with local packages
##### hVision non-Haskell deps
easyVisionSrc = "/home/timsears/code/easyVision"; #EDIT ME
hVision-lib = self.callPackage "${easyVisionSrc}/nix/hVision-lib" {};
ippLocal = self.callPackage "${easyVisionSrc}/nix/ippLocal" {};
ippPrivate = self.callPackage "${easyVisionSrc}/nix/ippLocal/ippPrivate.nix" {};

## a Haskell package with an attribute aliasing issue
zlib = super.zlib;
##

localPackages =
let zlib = super.zlib;
    easyVisionSrc = "/home/timsears/code/easyVision"; #EDIT ME
in
self: super: rec {
  # easyVisionProject
  artools = with self; callPackage "${easyVisionSrc}/nix/artools" {};
  easyVision = with self; callPackage "${easyVisionSrc}/nix/easyVision" {};
  easyVisionFull = with self; callPackage "${easyVisionSrc}/nix/easyVision-full" {};
  hVision = with self; callPackage "${easyVisionSrc}/nix/hVision" {};
  hVision-base = with self; callPackage "${easyVisionSrc}/nix/hVision-base" {};
  hVision-contours = with self; callPackage "${easyVisionSrc}/nix/hVision-contours" {};
  hVision-classifier = with self; callPackage "${easyVisionSrc}/nix/hVision-classifier" {};
  hVision-clipping = with self; callPackage "${easyVisionSrc}/nix/hVision-clipping" {};
  hVision-custom = with self; callPackage "${easyVisionSrc}/nix/hVision-custom" {};
  hVision-geometry = with self; callPackage "${easyVisionSrc}/nix/hVision-geometry" {};
  # hVision-gpu = with self; callPackage "${easyVisionSrc}/nix/hVision-gpu" {};
  hVision-gui = with self; callPackage "${easyVisionSrc}/nix/hVision-gui" {};
  hVision-ipp=  with self; callPackage "${easyVisionSrc}/nix/hVision-ipp" {};
  hVision-examples = with self; callPackage "${easyVisionSrc}/nix/hVision-examples" {};
  hVision-models3ds = with self; callPackage "{easyVisionSrc}/nix/hVision-models3ds" {};
  hVision-opencv = with self; callPackage "${easyVisionSrc}/nix/hVision-opencv" {};
  hVision-subpixel = with self; callPackage "${easyVisionSrc}/nix/hVision-subpixel" {};
  # hVision-tesseract = with self; callPackage "${easyVisionSrc}/nix/hVision-tesseract" {}; # bitrotted, optional anyway
  hVision-zbar = super.callPackage "${easyVisionSrc}/nix/hVision-zbar" {}; # bitrotted, optional anyway
  };

# Nix copies your source directory to a clean place to build and it detects changes n your source directory. If you are developing a package you want it to ignore some ththings that normally appear. This utility can be used in your .nix file.
# Usage e.g. src = builtins.filterSource shouldIgnoreFile path/to/some/project

shouldIgnoreFile = path: type:
with { inherit (super.lib) hasPrefix hasSuffix; };
         (let pathBaseName = baseNameOf path; in
               !(hasSuffix "~" pathBaseName) && # junk
               !(hasSuffix "#" pathBaseName) && # more junk
               !(hasPrefix ".git" pathBaseName) && # the git repo!
               !(hasPrefix "result" pathBaseName) && # old nix-build results
               # old cabal build results.
               # nix gets confused if dist/ is present with .cabal
               !(hasPrefix "dist" pathBaseName)
          );

};

}
